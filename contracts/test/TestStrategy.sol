// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {BaseStrategy, StrategyParams} from "../BaseStrategy.sol";

/*
 * This Strategy serves as both a mock Strategy for testing, and an example
 * for integrators on how to use BaseStrategy
 */

contract TestStrategy is BaseStrategy {
    constructor(address _vault) public BaseStrategy(_vault) {}

    function name() external override pure returns (string memory) {
        return "TestStrategy";
    }

    // NOTE: This is a test-only function to simulate losses
    function _takeFunds(uint256 amount) public {
        want.transfer(msg.sender, amount);
    }

    function estimatedTotalAssets() public override view returns (uint256) {
        // For mock, this is just everything we have
        return want.balanceOf(address(this));
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // During testing, send this contract some tokens to simulate "Rewards"
        uint256 totalAssets = want.balanceOf(address(this));
        uint256 totalDebt = vault.strategies(address(this)).totalDebt;
        if (totalAssets > _debtOutstanding) {
            _debtPayment = _debtOutstanding;
            totalAssets = totalAssets.sub(_debtOutstanding);
        } else {
            _debtPayment = totalAssets;
            totalAssets = 0;
        }
        totalDebt = totalDebt.sub(_debtPayment);

        if (totalAssets > totalDebt) {
            _profit = totalAssets.sub(totalDebt);
        } else {
            _loss = totalDebt.sub(totalAssets);
        }
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // Whatever we have "free", consider it "invested" now
    }

    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed) {
        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded >= totalAssets) {
            _amountFreed = totalAssets;
        } else {
            _amountFreed = _amountNeeded;
        }
    }

    function exitPosition(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        uint256 totalAssets = want.balanceOf(address(this));

        // Three possibilities, profit, breakeven, losses
        if (totalAssets >= _debtOutstanding) {
            _profit = totalAssets.sub(_debtOutstanding);
            _debtPayment = _debtOutstanding;
        } else {
            _debtPayment = totalAssets;
            _loss = _debtOutstanding.sub(totalAssets);
        }
    }

    function prepareMigration(address _newStrategy) internal override returns (bool _success){
        // Nothing needed here because no additional tokens/tokenized positions for mock
        return true;
    }

    function protectedTokens() internal override view returns (address[] memory) {
        return new address[](0); // No additional tokens/tokenized positions for mock
    }
}
